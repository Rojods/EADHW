//! Arithmethic operations with error handling.
//!
//! This crate provides rust bindings to the C library `arith` with graceful error handling.
//! In effect, this crate provides platform-specific arithmetic operations in a safe rust API.

/// internal module providing the private C bindings generated by bindgen.
mod carithm {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    include!(concat!(env!("OUT_DIR"), "/arithm_bindings.rs"));
}

/// Possible errors encounreted while performing arithmetic operations.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum ArithError {
    Overflow,
    Underflow,
    DivisionByZero,
}

/// Adds two 32-bit signed integers using platform-specific operations.
/// This function assumes that the platform default integer size is 32.
#[inline]
pub fn add(a: i32, b: i32) -> Result<i32, ArithError> {
    let c_res = unsafe { carithm::add(a, b) };
    if a > 0 && b > 0 && (c_res < a || c_res < b) {
        Err(ArithError::Overflow)
    } else if a < 0 && b < 0 && (c_res > a || c_res > b) {
        Err(ArithError::Underflow)
    } else {
        Ok(c_res)
    }
}

/// Subtract two 32-bit signed integers using platform-specific operations.
/// This function assumes that the platform default integer size is 32.
#[inline]
pub fn subtract(a: i32, b: i32) -> Result<i32, ArithError> {
    let c_res = unsafe { carithm::subtract(a, b) };
    if a > 0 && b < 0 && (c_res < a) {
        Err(ArithError::Overflow)
    } else if a < 0 && b > 0 && (c_res > b) {
        Err(ArithError::Underflow)
    } else {
        Ok(c_res)
    }
}

/// Multiply two 32-bit signed integers using platform-specific operations.
/// This function assumes that the platform default integer size is 32.
///
/// Currently this function uses a division operation to check whether the result has
/// overflown or underflown. Naturally this check might impact performance at the cost
/// of safety; thus, it is recommended that this function is reviewed and optimized
/// with platform specific knowledge to check for overflow and underflow using fast
/// operations like bit shifts. If the endianess, integer sizes and negative format
/// are known, a strategy that computes the result without division can be implemented.
#[inline]
pub fn multiply(a: i32, b: i32) -> Result<i32, ArithError> {
    if a == 0 || b == 0 {
        Ok(0)
    } else {
        let c_res = unsafe { carithm::multiply(a, b) };
        let a_potential =
            divide(c_res, b).expect("Division by zero is not possible due to the guard conditions");
        if a_potential == (a as f64) {
            Ok(c_res)
        } else {
            if (a > 0 && b > 0) || (a < 0 && b < 0) {
                Err(ArithError::Overflow)
            } else {
                Err(ArithError::Underflow)
            }
        }
    }
}

/// Divides two 32-bits signed integers using platform-specific operations,
/// assmuing that the platform default integer size is 32,
/// and returns a IEEE754 double-precision floating point number.
#[inline]
pub fn divide(numerator: i32, denominator: i32) -> Result<f64, ArithError> {
    let c_res = unsafe { carithm::divide(numerator, denominator) };
    if denominator == 0 {
        Err(ArithError::DivisionByZero)
    } else {
        Ok(c_res)
    }
}
